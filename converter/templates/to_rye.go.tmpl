{{ define "integer" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Integer, error) {
	return *_env.NewInteger(int64(x)), nil
}
{{- end }}


{{ define "complex" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Complex, error) {
	return *_env.NewComplex(complex128(x)), nil
}
{{- end }}


{{ define "float" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Decimal, error) {
	return *_env.NewDecimal(float64(x)), nil
}
{{- end }}


{{ define "bool" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Boolean, error) {
	return *_env.NewBoolean(x), nil
}
{{- end }}


{{ define "string" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.String, error) {
	return *_env.NewString(x), nil
}
{{- end }}


{{ define "pointer" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, s {{ typStr . }}) (_env.Object, error) {
	if s == nil {
		return *_env.NewVoid(), nil
	}
	return *_env.NewNative(ps.Idx, s, "go(" + {{ typStr . | quote }} + ")"), nil
}
{{- end }}


{{ define "error" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Object, error) {
	if x == nil {
		return *_env.NewVoid(), nil
	}
	return _env.NewError(x.Error()), nil
}
{{- end }}


{{ define "time" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Time, error) {
	return *_env.NewTime(x), nil
}
{{- end }}


{{ define "unsafePointer" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Native, error) {
	return *_env.NewNative(ps.Idx, x, "go(" + {{ typStr . | quote }} + ")"), nil
}
{{- end }}


{{ define "array" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, a {{ typStr . }}) (_env.Block, error) {
	var items [{{ .Len }}]_env.Object
	for i := range a {
		var err error
		items[i], err = {{ conv .Elem toRye }}(ps, a[i])
		if err != nil {
			return _env.Block{}, err
		}
	}
	return *_env.NewBlock(*_env.NewTSeries(items[:])), nil
}
{{- end }}


{{ define "slice" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, a {{ typStr . }}) (_env.Block, error) {
	items := make([]_env.Object, len(a))
	for i := range a {
		var err error
		items[i], err = {{ conv .Elem toRye }}(ps, a[i])
		if err != nil {
			return _env.Block{}, err
		}
	}
	return *_env.NewBlock(*_env.NewTSeries(items)), nil
}
{{- end }}


{{ define "map" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, m {{ typStr . }}) (_env.Dict, error) {
	{{ if eq .Key.String "string" -}}
	data := make(map[string]any, len(m))
	for k, v := range m {
		v1, err := {{ conv .Elem toRye }}(ps, v)
		if err != nil {
			return _env.Dict{}, err
		}
		data[k] = v1
	}
	return *_env.NewDict(data), nil
	{{- else -}}
	return *_env.NewNative(ps.Idx, m, "go({{ typStr . }})"), nil
	{{- end }}
}
{{- end }}


{{ define "named" -}}
{{- /* interface => we should try to emit the underlying type (if exported) instead of the interface */ -}}
{{- /* non-interface => we should assume the underlying type to be a pointer.
       This is because every type needs to be mutable if passed by reference.
       Making it a pointer is the only way to ensure we always have the variable's
	   memory address, since there is no "native-type stack" in Rye.
 */ -}}
{{- $interface := typIs "interface" .Underlying -}}
func {{ conv . toRye }}(ps *_env.ProgramState, s {{ typStr . }}) (_env.Object, error) {
	{{ if $interface -}}
	if s == nil {
		return *_env.NewVoid(), nil
	}
	if nat, ok := autoToNative(ps, s); ok {
		return nat, nil
	}
	{{ end -}}
	return *_env.NewNative(ps.Idx, {{ if not $interface }}&{{ end }}s, "go({{ if not $interface }}*{{ end }}{{ typStr . }})"), nil
}
{{- end }}


{{ define "struct" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, s {{ typStr . }}) (_env.Object, error) {
	return *_env.NewNative(ps.Idx, &s, "go(*{{ typStr . }})"), nil
}
{{- end }}


{{ define "any" -}}
func {{ conv . toRye }}(ps *_env.ProgramState, x {{ typStr . }}) (_env.Native, error) {
	if nat, ok := autoToNative(ps, x); ok {
		return nat, nil
	}
	return _env.Native{}, _errors.New("expected go(any) to have a known type, but got " + objectType(ps, x))
}
{{- end }}


{{ define "func" -}}
{{- $splitResults := splitErrResult .Results -}}
func {{ conv . toRye }}(ps *_env.ProgramState, fn {{ typStr . }}) (_env.VarBuiltin, error) {
	outfnErrable := func(ps *_env.ProgramState, args ..._env.Object) (_env.Object, error) {
		{{ range $i := $.Params.Len -}}
		arg{{ $i }}, err := {{ conv ($.Params.At $i).Type fromRye }}(ps, args[{{ $i }}])
		if err != nil {
			return *_env.NewVoid(), err
		}
		{{ end -}}
		{{ if .Results }} {{- seqWithPrefix .Results.Len "res" | join ", " }} := {{ end -}}
			fn({{ seqWithPrefix .Params.Len "arg" | join ", " }}{{ if .Variadic }}...{{ end }})
		{{ if $splitResults.Err -}}
		if res{{ sub .Results.Len 1 }} != nil {
			return *_env.NewVoid(), res{{ sub .Results.Len 1 }}
		}
		{{ end -}}
		{{ range $i := $splitResults.NonErr.Len -}}
		{{- $result := ($splitResults.NonErr.At $i).Type -}}
		outRes{{ $i }}, err := {{ conv $result toRye }}(ps, res{{ $i }})
		if err != nil {
			return *_env.NewVoid(), err
		}
		{{ end -}}
		{{ if eq $splitResults.NonErr.Len 0 -}}
		return *_env.NewVoid(), nil
		{{- else if eq $splitResults.NonErr.Len 1 -}}
		return outRes0, nil
		{{- else -}}
		return *_env.NewBlock(*_env.NewTSeries([]_env.Object{ {{- seqWithPrefix $splitResults.NonErr.Len "outRes" | join ", " -}} })), nil
		{{- end }}
	}

	return _env.VarBuiltin{
		Argsn: {{ .Params.Len }},
		Fn: func(ps *_env.ProgramState, args ..._env.Object) _env.Object {
			res, err := outfnErrable(ps, args...)
			if err != nil {
				ps.FailureFlag = true
				return _env.NewError(err.Error())
			}
			return res
		},
	}, nil
}
{{- end }}

{{ define "chan" }}
{{- template "defTranslateChan" . -}}

{{- /* We want the same channel to return the same converted channel. */ -}}
var chanInstances_{{ typHash . }}_toRye_live = map[{{ typStr . }}]chan *_env.Object{}
var chanInstances_{{ typHash . }}_toRye_mu _sync.Mutex

func {{ conv . toRye }}(ps *_env.ProgramState, goCh {{ typStr . }}) (_env.Object, error) {
	if goCh == nil {
		return *_env.NewVoid(), nil
	}
	chanInstances_{{ typHash . }}_toRye_mu.Lock()
	ryeCh, have := chanInstances_{{ typHash . }}_toRye_live[goCh]
	chanInstances_{{ typHash . }}_toRye_mu.Unlock()
	if !have {
		ryeCh = make(chan *_env.Object)
		go func() {
			chanInstances_{{ typHash . }}_toRye_mu.Lock()
			chanInstances_{{ typHash . }}_toRye_live[goCh] = ryeCh
			chanInstances_{{ typHash . }}_toRye_mu.Unlock()
			translateChan_{{ typHash . }}(ps, goCh, ryeCh)
			chanInstances_{{ typHash . }}_toRye_mu.Lock()
			delete(chanInstances_{{ typHash . }}_toRye_live, goCh)
			chanInstances_{{ typHash . }}_toRye_mu.Unlock()
		}()
	}
	return *_env.NewNative(ps.Idx, ryeCh, "Rye-channel"), nil
}
{{- end }}