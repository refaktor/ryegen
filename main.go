package main

import (
	"bufio"
	"bytes"
	"cmp"
	"errors"
	"flag"
	"fmt"
	"go/types"
	"io"
	"maps"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"runtime/pprof"
	"slices"
	"strconv"
	"strings"
	"time"

	"dario.cat/mergo"
	"github.com/refaktor/ryegen/v2/config"
	"github.com/refaktor/ryegen/v2/converter"
	"github.com/refaktor/ryegen/v2/converter/typeset"
	"github.com/refaktor/ryegen/v2/digraphutils"
	"github.com/refaktor/ryegen/v2/loader"
	"golang.org/x/tools/go/packages"
)

func isEnvTrue(name string) bool {
	return slices.Contains(
		[]string{"1", "true", "yes"},
		strings.ToLower(os.Getenv(name)),
	)
}

func handleEnvProfile(logger *Logger) (stop func()) {
	if !isEnvTrue("RYEGEN_PROFILE") {
		return func() {}
	}

	const path = "ryegen_cpu.prof"
	logger.Log(INFO, "profiling enabled, target=%v", path)
	f, err := os.Create(path)
	if err != nil {
		logger.Log(FATAL, "writing profile: %v", err)
	}
	//runtime.SetCPUProfileRate(500)
	if err := pprof.StartCPUProfile(f); err != nil {
		logger.Log(FATAL, "starting profiling: %v", err)
	}
	return func() {
		logger.Log(INFO, "profile saved to %v", path)
		pprof.StopCPUProfile()
		f.Close()
	}
}

func tryRunDOT(logger *Logger, args ...string) {
	const cmd = "dot"
	if _, err := exec.LookPath(cmd); err == nil {
		logger.Log(INFO, "running: %v %v", cmd, strings.Join(args, " "))
		if err := exec.Command(cmd, args...).Run(); err != nil {
			logger.Log(ERROR, "error running %v: %v", cmd, err)
		}
	} else {
		logger.Log(WARN, "command %v not found; please install graphviz to automatically convert graphs to SVG", cmd)
	}
}

func handleEnvConvGraph(logger *Logger, graph *converter.Graph) (stop func()) {
	reStr := os.Getenv("RYEGEN_CONV_GRAPH")
	if reStr == "" {
		return func() {}
	}

	const pathBase = "ryegen_conv_graph"
	const gvPath = pathBase + ".gv"
	logger.Log(INFO, "converter dependency graph enabled, regexp=%v, target=%v", reStr, gvPath)
	return func() {
		re, err := regexp.Compile(reStr)
		if err != nil {
			logger.Log(FATAL, "converter dependency selection regex: %v", err)
		}
		logger.Log(INFO, "writing converter dependency graph to %v", gvPath)
		code := graph.DebugDOTCode(re)
		if err := os.WriteFile(gvPath, code, 0666); err != nil {
			logger.Log(FATAL, "writing converter dependency graph: %v", err)
		}
		tryRunDOT(logger, "-Tsvg", gvPath, "-o", pathBase+".svg")
	}
}

func handleImportGraph(logger *Logger, graph map[string][]string) (stop func()) {
	reStr := os.Getenv("RYEGEN_IMPORT_GRAPH")
	if reStr == "" {
		return func() {}
	}

	const pathBase = "ryegen_import_graph"
	const gvPath = pathBase + ".gv"
	logger.Log(INFO, "import graph enabled, regexp=%v, target=%v", reStr, gvPath)
	return func() {
		re, err := regexp.Compile(reStr)
		if err != nil {
			logger.Log(FATAL, "import graph selection regex: %v", err)
		}

		var roots []string
		for node := range graph {
			if re.MatchString(node) {
				roots = append(roots, node)
			}
		}

		reachable := slices.Sorted(maps.Keys(
			digraphutils.Reachable(
				roots,
				func(k string) []string { return graph[k] },
			),
		))
		code := digraphutils.DOTCode(
			reachable,
			func(k string) []string { return graph[k] },
			"import_graph",
			"node[shape=box, style=filled]",
			func(k string) string { return fmt.Sprintf("[label=%v]", strconv.Quote(k)) },
		)
		logger.Log(INFO, "writing import graph to %v", gvPath)
		if err := os.WriteFile(gvPath, code, 0666); err != nil {
			logger.Log(FATAL, "writing import graph: %v", err)
		}
		tryRunDOT(logger, "-Tsvg", gvPath, "-o", pathBase+".svg")
	}
}

func handlePrintTime(logger *Logger) (stop func()) {
	now := time.Now()
	return func() {
		logger.Log(INFO, "execution took %v", time.Since(now))
	}
}

func isFileGeneratedByRyegen(path string) (bool, error) {
	name := filepath.Base(path)
	if !strings.HasPrefix(name, "ryegen_") ||
		!strings.HasSuffix(name, ".gen.go") {
		return false, nil
	}

	if info, err := os.Stat(path); err != nil {
		return false, err
	} else if !info.Mode().IsRegular() {
		return false, nil
	}

	f, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer f.Close()

	line, err := bufio.NewReader(f).ReadString('\n')
	if err != nil {
		if errors.Is(err, io.EOF) {
			return false, nil
		}
		return false, err
	}
	if !strings.HasPrefix(line, "// Code generated by ryegen") ||
		!strings.HasSuffix(line, "; DO NOT EDIT.\n") {
		return false, nil
	}
	return true, nil
}

func boolToBinStr(b bool) string {
	if b {
		return "1"
	} else {
		return "0"
	}
}

type TagsValue struct {
	V *[]string
}

func (v TagsValue) String() string {
	if v.V == nil {
		return ""
	}
	return strings.Join(*v.V, ",")
}

func (v TagsValue) Set(s string) error {
	if s == "" {
		*v.V = nil
	}
	*v.V = slices.DeleteFunc(
		strings.Split(s, ","),
		func(x string) bool { return x == "" })
	return nil
}

// e.g. github.com/someone/somerepo => github_com_someone_somerepo
func packagePathToImportName(path string) string {
	return strings.NewReplacer("/", "_", ".", "_", "-", "_").Replace(path)
}

func main() {
	var optClean = flag.Bool("clean", false, "delete Go files generated by Ryegen (pwd by default, or you can specify the directories as args)")
	var optQuiet = flag.Bool("q", false, "quiet: hide warnings")
	var optVerbose = flag.Bool("v", false, "verbose output")
	var optGOOS = flag.String("goos", runtime.GOOS, "target operating system")
	var optGOARCH = flag.String("goarch", runtime.GOARCH, "target CPU architecture")
	var optTags []string
	flag.Var(TagsValue{V: &optTags}, "tags", "additional target build tags (separated by ,)")
	flag.Parse()

	logger := &Logger{
		Writer:   os.Stdout,
		Prefix:   "Ryegen",
		MinLevel: WARN,
	}
	if *optVerbose {
		logger.MinLevel = INFO
	}
	if *optQuiet {
		logger.MinLevel = ERROR
	}

	defer handleEnvProfile(logger)()
	defer handlePrintTime(logger)()

	if *optClean {
		dirs := flag.Args()
		if len(dirs) == 0 {
			dirs = []string{"."}
		}
		var files []string
		for _, dir := range dirs {
			ents, err := os.ReadDir(dir)
			if err != nil {
				logger.Log(FATAL, "failed to read directory %v: %v", dir, err)
			}
			for _, ent := range ents {
				path := filepath.Join(dir, ent.Name())
				generated, err := isFileGeneratedByRyegen(path)
				if err != nil {
					logger.Log(FATAL, "failed to read file %v: %v", dir, err)
				}
				if generated {
					files = append(files, path)
				}
			}
		}
		for _, f := range files {
			if err := os.Remove(f); err != nil {
				logger.Log(FATAL, "failed to delete file %v: %v", f, err)
			}
		}
		return
	}

	codeGeneratedLine := func(withArgs bool) string {
		var args string
		if withArgs && len(os.Args) > 1 {
			args = " " + strings.Join(os.Args[1:], " ")
		}
		return fmt.Sprintf("// Code generated by ryegen%v; DO NOT EDIT.\n", args)
	}

	cfg, err := config.Load("ryegen.toml")
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			logger.Log(FATAL, "ryegen.toml not found")
		} else if cfgErr := (&config.Error{}); errors.As(err, &cfgErr) {
			logger.Log(FATAL, "unable to load ryegen.toml: %v", cfgErr.String())
		} else {
			logger.Log(FATAL, "unable to load ryegen.toml: %v", err)
		}
	}

	loaderCfg := &loader.Config{}

	for _, src := range cfg.Sources {
		loaderCfg.PackagePatterns = append(loaderCfg.PackagePatterns,
			src.Packages...)
	}

	var target config.Target
	var targetName string
	{
		targetName = strings.Join(
			append([]string{*optGOOS, *optGOARCH}, optTags...),
			"_")

		// TODO: Add unix tag if GOOS is unix
		var tags []string
		tags = append(tags, *optGOOS, *optGOARCH)
		tags = append(tags, optTags...)
		if !slices.Contains(tags, "gc") && !slices.Contains(tags, "gccgo") {
			tags = append(tags, runtime.Compiler)
		}

		var foundTarget bool
		for _, tgt := range cfg.Targets {
			if tgt.Select == nil || tgt.Select.Eval(func(tag string) bool {
				return slices.Contains(tags, tag)
			}) {
				if err := mergo.Merge(&target, &tgt); err != nil {
					logger.Log(FATAL, "unable to merge matching targets: %v", err)
				}
				foundTarget = true
			}
		}
		if !foundTarget {
			logger.Log(FATAL, "no matching target found in ryegen.toml for selected build tags (%v)", strings.Join(tags, ","))
		}
	}

	loaderCfg.Env = append(loaderCfg.Env,
		"GOOS="+*optGOOS,
		"GOARCH="+*optGOARCH,
		"CGO_ENABLED="+boolToBinStr(*target.CGoEnabled),
	)
	loaderCfg.BuildFlags = append(loaderCfg.BuildFlags,
		"-tags="+strings.Join(optTags, ","),
	)

	{
		pkgs, err := loader.ResolvePatterns(loaderCfg)
		if err != nil {
			logger.Log(FATAL, "failed to resolve package patterns: %v", err)
		}

		var out bytes.Buffer
		out.WriteString(codeGeneratedLine(false))
		out.WriteString("package main\n\n")
		out.WriteString("import (\n")
		for _, pkg := range pkgs {
			fmt.Fprintf(&out, "\t_ \"%v\"\n", pkg)
		}
		out.WriteString(")\n")
		if err := os.WriteFile("ryegen_deps.gen.go", out.Bytes(), 0666); err != nil {
			logger.Log(FATAL, "writing ryegen_deps: %v", err)
		}
	}

	pkgs, err := loader.Load(loaderCfg)
	if err != nil {
		logger.Log(FATAL, `failed to load packages: %v
re-running after \"go mod tidy\" might fix the error`, err)
	}

	basePkg := "main"
	qualifier := types.Qualifier(func(p *types.Package) string {
		path := p.Path()
		if path == basePkg {
			return ""
		}
		return packagePathToImportName(path)
	})
	tset := typeset.New(qualifier)

	cs := converter.NewConverterSet(tset, basePkg)

	shouldVisitPackage := func(p *packages.Package) bool {
		for elem := range strings.SplitSeq(p.PkgPath, "/") {
			if elem == "internal" || elem == "cmd" {
				return false
			}
		}
		if strings.HasPrefix(p.PkgPath, "vendor/") {
			// Ignore Go vendored std library modules.
			// See https://cs.opensource.google/go/go/+/master:src/README.vendor.
			// TODO: Figure out if this could break
			// user-vendored modules.
			return false
		}
		return true
	}

	bset := newBindingSet()

	dbgImportGraph := map[string][]string{} // pkg path to imported paths; for debugging
	{
		seen := map[string]bool{}
		var visit func(p *packages.Package) error
		visit = func(p *packages.Package) error {
			if seen[p.PkgPath] {
				return nil
			}
			seen[p.PkgPath] = true
			if !shouldVisitPackage(p) {
				return nil
			}

			bfs := makePkgBindings(tset, p.TypesInfo, p.Syntax)
			bfs, err := bset.addWithRules(cfg, bfs)
			if err != nil {
				return fmt.Errorf("failed to apply binding rules: %v", err)
			}

			// We only want to make bindings for the imports actually
			// used by at least one of the bindings in this package
			// (after applying binding rules).
			usedImports := map[string]bool{}
			for _, bf := range bfs {
				// In this case, we're collecting all imports required
				// to represent the required converter func. I'm pretty
				// sure - but not 100% - that this should correspond
				// to collecting all API dependencies.
				for _, pkg := range collectImports(bf.requiredConverter) {
					usedImports[pkg.Path()] = true
				}
			}

			imports := make([]*packages.Package, 0, len(p.Imports))
			for _, imp := range p.Imports {
				if !seen[imp.PkgPath] && usedImports[imp.PkgPath] {
					imports = append(imports, imp)
				}
			}
			slices.SortFunc(imports, func(a, b *packages.Package) int { return cmp.Compare(a.PkgPath, b.PkgPath) })
			{
				paths := make([]string, len(imports))
				for i, imp := range imports {
					paths[i] = imp.PkgPath
				}
				dbgImportGraph[p.PkgPath] = paths
			}
			for _, imp := range imports {
				if err := visit(imp); err != nil {
					return err
				}
			}
			return nil
		}
		for _, p := range pkgs {
			if err := visit(p); err != nil {
				logger.Log(FATAL, "visit packages: %v", err)
			}
		}
	}
	defer handleImportGraph(logger, dbgImportGraph)()

	writeImports := func(w io.Writer, packagePaths []string) {
		fmt.Fprintf(w, "import (\n")
		for _, imp := range packagePaths {
			fmt.Fprintf(w, "\t%v \"%v\"\n", packagePathToImportName(imp), imp)
		}
		fmt.Fprintf(w, ")\n\n")
	}

	var goBuildLine string
	{
		goBuildLine = "//go:build " + *optGOOS + " && " + *optGOARCH
		if *target.CGoEnabled {
			goBuildLine += " && cgo"
		}
		if optTags != nil {
			goBuildLine += " && " + strings.Join(optTags, " && ")
		}
		goBuildLine += "\n"
	}

	bindings := slices.DeleteFunc(bset.bindings, func(bf binding) bool { return bf.props.exclude })
	bset.invalid = true // bset.bindings may be invalid ... just to be sure

	var code []byte
	var graph *converter.Graph
	{
		packageToBindingFuncs := map[string]map[string]binding{}   // package to func name to bindingFunc
		packageToBindingConvName := map[string]map[string]string{} // package to func name to conv name
		for _, fn := range bindings {
			pkg := fn.props.pkgPath
			if pkg == "" {
				// Special pseudo-package for bindings that may not be
				// package-specific, e.g. struct aliases.
				pkg = "zz_global"
			}
			convName := cs.Add(fn.requiredConverter, converter.ToRye, pkg+"::"+fn.key())
			if packageToBindingFuncs[pkg] == nil {
				packageToBindingFuncs[pkg] = map[string]binding{}
				packageToBindingConvName[pkg] = map[string]string{}
			}
			packageToBindingFuncs[pkg][fn.key()] = fn
			packageToBindingConvName[pkg][fn.key()] = convName
		}

		var convErr *converter.ConverterError
		code, graph, err = cs.Code()
		if err != nil {
			if errors.As(err, &convErr) {
				logger.Log(WARN, "some converters had errors:\n%v", convErr.String())
			} else {
				logger.Log(FATAL, "failed to generate converter code: %v", err)
			}
		}

		bindingFuncImports := map[string]struct{}{}
		for _, fn := range bindings {
			var pkg string
			if fn.pkg != nil {
				pkg = fn.props.pkgPath
			}
			if !graph.Contains(fn.requiredConverter, converter.ToRye) {
				delete(packageToBindingFuncs[pkg], fn.key())
				delete(packageToBindingConvName[pkg], fn.key())
				continue
			}
			for _, imp := range fn.funcCodeImports {
				bindingFuncImports[imp.Path()] = struct{}{}
			}
		}

		var out bytes.Buffer
		out.WriteString(codeGeneratedLine(true))
		out.WriteString(goBuildLine)
		out.WriteString("package main\n\n")
		writeImports(&out, slices.Sorted(maps.Keys(bindingFuncImports)))
		out.WriteString(builtinsCommonCode)
		for _, pkg := range slices.Sorted(maps.Keys(packageToBindingFuncs)) {
			bfs := packageToBindingFuncs[pkg]
			mapName := "builtins_" + packagePathToImportName(pkg)
			// HACK: Putting the builtins into a map literal directly will cause a compiler error
			// if there are too many items.
			// E.g.: "internal compiler error: NewBulk too big: nbit=48093 count=589148 nword=1503 size=885489444"
			fmt.Fprintf(&out, "var %v = make(map[string]*_env.VarBuiltin, %v)\n", mapName, len(bfs))
			if len(bfs) > 0 {
				// Due to the same Go compiler bug, we also have
				// to break up very large funcs into smaller ones.
				idxInChunk := 0
				const chunkSize = 512
				startChunk := func() {
					fmt.Fprintf(&out, "func init() {\n")
					fmt.Fprintf(&out, "\t"+`m := %v`+"\n", mapName)
				}
				endChunk := func() {
					fmt.Fprintf(&out, "}\n\n")
				}

				startChunk()
				for _, bf := range slices.Sorted(maps.Keys(bfs)) {
					if idxInChunk >= chunkSize {
						idxInChunk = 0
						endChunk()
						startChunk()
					}

					fn := bfs[bf]
					convName := packageToBindingConvName[pkg][bf]
					fmt.Fprintf(&out, "\t"+`m["%v"] = %v`+"\n", fn.key(), fn.binding(convName))
					idxInChunk++
				}
				endChunk()
			}
		}
		fmt.Fprintf(&out, "var builtins = make(map[string]map[string]*_env.VarBuiltin, %v)\n", len(packageToBindingFuncs))
		fmt.Fprintf(&out, "func init() {\n")
		for _, pkg := range slices.Sorted(maps.Keys(packageToBindingFuncs)) {
			fmt.Fprintf(&out, "\t"+`builtins["%v"] = builtins_%v`+"\n", pkg, packagePathToImportName(pkg))
		}
		out.WriteString("}\n\n")
		err := os.WriteFile("ryegen_builtins_"+targetName+".gen.go", out.Bytes(), 0666)
		if err != nil {
			logger.Log(FATAL, "writing ryegen_builtins: %v", err)
		}
	}
	defer handleEnvConvGraph(logger, graph)()
	{
		var out bytes.Buffer
		out.WriteString(codeGeneratedLine(true))
		out.WriteString(goBuildLine)
		out.WriteString("package main\n\n")
		out.Write(code)
		if err := os.WriteFile("ryegen_convs_"+targetName+".gen.go", out.Bytes(), 0666); err != nil {
			logger.Log(FATAL, "writing ryegen_convs: %v", err)
		}
	}
}
