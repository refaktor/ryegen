package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/types"
	"io"
	"log"
	"maps"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"runtime/pprof"
	"slices"
	"strings"
	"time"

	"dario.cat/mergo"
	"github.com/refaktor/ryegen/v2/config"
	"github.com/refaktor/ryegen/v2/converter"
	"github.com/refaktor/ryegen/v2/converter/typeset"
	"github.com/refaktor/ryegen/v2/loader"
	"golang.org/x/tools/go/packages"
)

func isEnvTrue(name string) bool {
	return slices.Contains(
		[]string{"1", "true", "yes"},
		strings.ToLower(os.Getenv(name)),
	)
}

func handleEnvProfile() (stop func()) {
	if !isEnvTrue("RYEGEN_PROFILE") {
		return func() {}
	}

	const path = "ryegen_cpu.prof"
	fmt.Println("Ryegen: profiling enabled, writing to", path)
	f, err := os.Create(path)
	if err != nil {
		log.Fatal(err)
	}
	//runtime.SetCPUProfileRate(500)
	if err := pprof.StartCPUProfile(f); err != nil {
		log.Fatal(err)
	}
	return func() {
		fmt.Println("Ryegen: profile saved to", path)
		pprof.StopCPUProfile()
		f.Close()
	}
}

func handleEnvConvGraph(graph *converter.Graph) (stop func()) {
	reStr := os.Getenv("RYEGEN_CONV_GRAPH")
	if reStr == "" {
		return func() {}
	}

	const path = "ryegen_conv_graph.gv"
	fmt.Println("Ryegen: converter dependency graph enabled, will write to", path)
	return func() {
		re, err := regexp.Compile(reStr)
		if err != nil {
			log.Fatal("Converter dependency selection regex:", err)
		}
		fmt.Println("Ryegen: writing converter dependency graph to", path)
		code := graph.DebugDOTCode(re)
		if err := os.WriteFile(path, code, 0666); err != nil {
			log.Fatal(err)
		}
	}
}

func handlePrintTime() (stop func()) {
	now := time.Now()
	return func() {
		fmt.Println("Ryegen: took", time.Since(now))
	}
}

func isFileGeneratedByRyegen(path string) (bool, error) {
	name := filepath.Base(path)
	if !strings.HasPrefix(name, "ryegen_") ||
		!strings.HasSuffix(name, ".gen.go") {
		return false, nil
	}

	if info, err := os.Stat(path); err != nil {
		return false, err
	} else if !info.Mode().IsRegular() {
		return false, nil
	}

	f, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer f.Close()

	line, err := bufio.NewReader(f).ReadString('\n')
	if err != nil {
		if errors.Is(err, io.EOF) {
			return false, nil
		}
		return false, err
	}
	if !strings.HasPrefix(line, "// Code generated by ryegen") ||
		!strings.HasSuffix(line, "; DO NOT EDIT.\n") {
		return false, nil
	}
	return true, nil
}

func boolToBinStr(b bool) string {
	if b {
		return "1"
	} else {
		return "0"
	}
}

type TagsValue struct {
	V *[]string
}

func (v TagsValue) String() string {
	if v.V == nil {
		return ""
	}
	return strings.Join(*v.V, ",")
}

func (v TagsValue) Set(s string) error {
	if s == "" {
		*v.V = nil
	}
	*v.V = slices.DeleteFunc(
		strings.Split(s, ","),
		func(x string) bool { return x == "" })
	return nil
}

func packagePathToImportName(path string) string {
	return strings.NewReplacer("/", "_", ".", "_", "-", "_").Replace(path)
}

func main() {
	defer handleEnvProfile()()
	defer handlePrintTime()()

	var optClean = flag.Bool("clean", false, "Delete Go files generated by Ryegen (pwd by default, or you can specify the directories as args)")
	var optGOOS = flag.String("goos", runtime.GOOS, "Target operating system")
	var optGOARCH = flag.String("goarch", runtime.GOARCH, "Target CPU architecture")
	var optTags []string
	flag.Var(TagsValue{V: &optTags}, "tags", "Additional target build tags (separated by ,)")
	flag.Parse()

	if *optClean {
		dirs := flag.Args()
		if len(dirs) == 0 {
			dirs = []string{"."}
		}
		var files []string
		for _, dir := range dirs {
			ents, err := os.ReadDir(dir)
			if err != nil {
				fmt.Println(err)
				os.Exit(1)
			}
			for _, ent := range ents {
				path := filepath.Join(dir, ent.Name())
				generated, err := isFileGeneratedByRyegen(path)
				if err != nil {
					fmt.Println(err)
					os.Exit(1)
				}
				if generated {
					files = append(files, path)
				}
			}
		}
		for _, f := range files {
			if err := os.Remove(f); err != nil {
				fmt.Println(err)
				os.Exit(1)
			}
		}
		return
	}

	codeGeneratedLine := func(withArgs bool) string {
		var args string
		if withArgs && len(os.Args) > 1 {
			args = " " + strings.Join(os.Args[1:], " ")
		}
		return fmt.Sprintf("// Code generated by ryegen%v; DO NOT EDIT.\n", args)
	}

	cfg, err := config.Load("ryegen.toml")
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			fmt.Println("ryegen.toml not found")
		} else if cfgErr := (&config.Error{}); errors.As(err, &cfgErr) {
			fmt.Println(cfgErr.String())
		} else {
			fmt.Println(err)
		}
		os.Exit(1)
	}

	loaderCfg := &loader.Config{}

	for _, src := range cfg.Sources {
		loaderCfg.PackagePatterns = append(loaderCfg.PackagePatterns,
			src.Packages...)
	}

	var target config.Target
	var targetName string
	{
		targetName = strings.Join(
			append([]string{*optGOOS, *optGOARCH}, optTags...),
			"_")

		// TODO: Add unix tag if GOOS is unix
		var tags []string
		tags = append(tags, *optGOOS, *optGOARCH)
		tags = append(tags, optTags...)
		if !slices.Contains(tags, "gc") && !slices.Contains(tags, "gccgo") {
			tags = append(tags, runtime.Compiler)
		}

		var foundTarget bool
		for _, tgt := range cfg.Targets {
			if tgt.Select == nil || tgt.Select.Eval(func(tag string) bool {
				return slices.Contains(tags, tag)
			}) {
				if err := mergo.Merge(&target, &tgt); err != nil {
					fmt.Println("merging matching targets:", err)
					os.Exit(1)
				}
				foundTarget = true
			}
		}
		if !foundTarget {
			fmt.Printf("No matching target found in ryegen.toml for your build tags (%v)",
				strings.Join(tags, ","))
		}
	}

	loaderCfg.Env = append(loaderCfg.Env,
		"GOOS="+*optGOOS,
		"GOARCH="+*optGOARCH,
		"CGO_ENABLED="+boolToBinStr(*target.CGoEnabled),
	)
	loaderCfg.BuildFlags = append(loaderCfg.BuildFlags,
		"-tags="+strings.Join(optTags, ","),
	)

	{
		pkgs, err := loader.ResolvePatterns(loaderCfg)
		if err != nil {
			fmt.Println("resolving package patterns:", err)
			os.Exit(1)
		}

		var out bytes.Buffer
		out.WriteString(codeGeneratedLine(false))
		out.WriteString("package main\n\n")
		out.WriteString("import (\n")
		for _, pkg := range pkgs {
			fmt.Fprintf(&out, "\t_ \"%v\"\n", pkg)
		}
		out.WriteString(")\n")
		if err := os.WriteFile("ryegen_deps.gen.go", out.Bytes(), 0666); err != nil {
			log.Fatal(err)
		}
	}

	pkgs, err := loader.Load(loaderCfg)
	if err != nil {
		fmt.Println("loading packages:", err)
		fmt.Println("Re-running after \"go mod tidy\" might fix the error")
		os.Exit(1)
	}

	basePkg := "main"
	qualifier := types.Qualifier(func(p *types.Package) string {
		path := p.Path()
		if path == basePkg {
			return ""
		}
		return packagePathToImportName(path)
	})
	tset := typeset.New(qualifier)

	cs := converter.NewConverterSet(tset, basePkg)

	var bindings []binding

	shouldVisitPackage := func(p *packages.Package) bool {
		for elem := range strings.SplitSeq(p.PkgPath, "/") {
			if elem == "internal" || elem == "cmd" {
				return false
			}
		}
		if strings.HasPrefix(p.PkgPath, "vendor/") {
			// Ignore Go vendored std library modules.
			// See https://cs.opensource.google/go/go/+/master:src/README.vendor.
			// TODO: Figure out if this could break
			// user-vendored modules.
			return false
		}
		return true
	}
	packages.Visit(pkgs, shouldVisitPackage, func(p *packages.Package) {
		if !shouldVisitPackage(p) {
			return
		}
		bindings = addFileBindings(bindings, tset, p.Types, p.TypesInfo, p.Syntax)
	})

	if err := applyBindingRules(cfg, &bindings); err != nil {
		fmt.Println("applying binding rules:", err)
		os.Exit(1)
	}

	writeImports := func(w io.Writer, packagePaths []string) {
		fmt.Fprintf(w, "import (\n")
		for _, imp := range packagePaths {
			fmt.Fprintf(w, "\t%v \"%v\"\n", packagePathToImportName(imp), imp)
		}
		fmt.Fprintf(w, ")\n\n")
	}

	var goBuildLine string
	{
		goBuildLine = "//go:build " + *optGOOS + " && " + *optGOARCH
		if *target.CGoEnabled {
			goBuildLine += " && cgo"
		}
		if optTags != nil {
			goBuildLine += " && " + strings.Join(optTags, " && ")
		}
		goBuildLine += "\n"
	}

	var code []byte
	var graph *converter.Graph
	defer handleEnvConvGraph(graph)()
	{
		packageToBindingFuncs := map[string]map[string]binding{}   // package to func name to bindingFunc
		packageToBindingConvName := map[string]map[string]string{} // package to func name to conv name
		for _, fn := range bindings {
			pkg := fn.props.pkgPath
			if pkg == "" {
				// Special pseudo-package for bindings that may not be
				// package-specific, e.g. struct aliases.
				pkg = "zz_global"
			}
			convName := cs.Add(fn.requiredConverter, converter.ToRye, pkg+"::"+fn.key())
			if packageToBindingFuncs[pkg] == nil {
				packageToBindingFuncs[pkg] = map[string]binding{}
				packageToBindingConvName[pkg] = map[string]string{}
			}
			packageToBindingFuncs[pkg][fn.key()] = fn
			packageToBindingConvName[pkg][fn.key()] = convName
		}

		var convErr *converter.ConverterError
		code, graph, err = cs.Code()
		if err != nil {
			if errors.As(err, &convErr) {
				fmt.Print(convErr.String())
			} else {
				log.Fatal(err)
			}
		}

		bindingFuncImports := map[string]struct{}{}
		for _, fn := range bindings {
			var pkg string
			if fn.pkg != nil {
				pkg = fn.props.pkgPath
			}
			if !graph.Contains(fn.requiredConverter, converter.ToRye) {
				delete(packageToBindingFuncs[pkg], fn.key())
				delete(packageToBindingConvName[pkg], fn.key())
				continue
			}
			for _, imp := range fn.requiredImports {
				bindingFuncImports[imp.Path()] = struct{}{}
			}
		}

		var out bytes.Buffer
		out.WriteString(codeGeneratedLine(true))
		out.WriteString(goBuildLine)
		out.WriteString("package main\n\n")
		writeImports(&out, slices.Sorted(maps.Keys(bindingFuncImports)))
		out.WriteString(builtinsCommonCode)
		for _, pkg := range slices.Sorted(maps.Keys(packageToBindingFuncs)) {
			bfs := packageToBindingFuncs[pkg]
			mapName := "builtins_" + packagePathToImportName(pkg)
			// HACK: Putting the builtins into a map literal directly will cause a compiler error
			// if there are too many items.
			// E.g.: "internal compiler error: NewBulk too big: nbit=48093 count=589148 nword=1503 size=885489444"
			fmt.Fprintf(&out, "var %v = make(map[string]*_env.VarBuiltin, %v)\n", mapName, len(bfs))
			if len(bfs) > 0 {
				// Due to the same Go compiler bug, we also have
				// to break up very large funcs into smaller ones.
				idxInChunk := 0
				const chunkSize = 512
				startChunk := func() {
					fmt.Fprintf(&out, "func init() {\n")
					fmt.Fprintf(&out, "\t"+`m := %v`+"\n", mapName)
				}
				endChunk := func() {
					fmt.Fprintf(&out, "}\n\n")
				}

				startChunk()
				for _, bf := range slices.Sorted(maps.Keys(bfs)) {
					if idxInChunk >= chunkSize {
						idxInChunk = 0
						endChunk()
						startChunk()
					}

					fn := bfs[bf]
					convName := packageToBindingConvName[pkg][bf]
					fmt.Fprintf(&out, "\t"+`m["%v"] = %v`+"\n", fn.key(), fn.binding(convName))
					idxInChunk++
				}
				endChunk()
			}
		}
		fmt.Fprintf(&out, "var builtins = make(map[string]map[string]*_env.VarBuiltin, %v)\n", len(packageToBindingFuncs))
		fmt.Fprintf(&out, "func init() {\n")
		for _, pkg := range slices.Sorted(maps.Keys(packageToBindingFuncs)) {
			fmt.Fprintf(&out, "\t"+`builtins["%v"] = builtins_%v`+"\n", pkg, packagePathToImportName(pkg))
		}
		out.WriteString("}\n\n")
		err := os.WriteFile("ryegen_builtins_"+targetName+".gen.go", out.Bytes(), 0666)
		if err != nil {
			log.Fatal(err)
		}
	}
	{
		var out bytes.Buffer
		out.WriteString(codeGeneratedLine(true))
		out.WriteString(goBuildLine)
		out.WriteString("package main\n\n")
		out.Write(code)
		if err := os.WriteFile("ryegen_convs_"+targetName+".gen.go", out.Bytes(), 0666); err != nil {
			log.Fatal(err)
		}
	}
}
